<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="Matrix" Id="{37681762-a9e8-4dd1-b97b-ca342c51c659}" SpecialFunc="None">
    <Declaration><![CDATA[(*
Matrix Base Class
=============

Overview
-------------

This abstract class encapsulates the logic of manipulating and interacting with matricies without forcing a specific memory management pattern.
Derived classes are:

- DynamicMatrix: A concrete class that dynamically allocates memory to take any form needed
- StaticMatrix: An abstract class that serves as the base for classes with fixed memory sources
- MatrixAccessor: An abstract class that serves as the base for classes that inherit the memory of another matrix and remap it to their own form
 
With either pattern the memory is accessed as a row-major 1D array of LREAL.

*)
{attribute 'reflection'}
{attribute 'no_assign'}
FUNCTION_BLOCK ABSTRACT Matrix
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR

	
	{attribute 'instance-path'}
	{attribute 'noinit'}
	sPath_ : T_MaxString;
	
	Ri : UINT;
	Ci : UINT;
	I : UINT;
	
	ZeroReference_ : LREAL;//numbers below this are considered zero for the purposes of avoiding near-divide-by-zero floating point issues
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[LogMessage('%s: There is no need to call the main FB function for type Matrix');]]></ST>
    </Implementation>
    <Folder Name="Accessors" Id="{ef6a5473-da01-0d79-286e-6646d04a6f5a}" />
    <Folder Name="Aggregators" Id="{c541bfa3-492b-0df6-1926-f02606816bce}" />
    <Folder Name="Comparators" Id="{b7fe62c6-6f13-454d-9f2a-eae01884c717}" />
    <Folder Name="Getters" Id="{764d70ab-da43-41bc-a172-c1370fa4e2a7}" />
    <Folder Name="Helpers" Id="{c18f9319-b519-4a83-98b2-43ca8f72caca}" />
    <Folder Name="Modifiers" Id="{0b7b615a-d2d6-4e62-b148-1a83ef247c62}" />
    <Folder Name="Properties" Id="{63bcd68f-51b7-4cdd-bc76-abfb7c04d216}" />
    <Folder Name="Protected" Id="{52ab6c01-12bf-4ee4-b7d8-7459de792de0}" />
    <Property Name="Average" Id="{bbb5565e-c8b8-06a4-072f-2f69a4299899}" FolderPath="Aggregators\">
      <Declaration><![CDATA[//returns the average value of all elements
PROPERTY PUBLIC Average : LREAL]]></Declaration>
      <Get Name="Get" Id="{3df0d655-ce9c-0473-3f0c-ac0787664407}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF Length > 0 THEN
	Average := Sum / Length;
ELSE
	Average := 0;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="BufferSize" Id="{f271d29f-8d22-4870-9606-910840251c4c}" FolderPath="Properties\">
      <Declaration><![CDATA[//The length (in Bytes) of the memory allocated to storing element data for this matrix
PROPERTY PUBLIC BufferSize : UDINT]]></Declaration>
      <Get Name="Get" Id="{cde88b07-59bd-48ab-b6be-612e25f0f9b5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[BufferSize := SIZEOF(LREAL)*Length;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Clear" Id="{788b000b-9652-4513-87ea-afa0efbc93b4}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Resets the value of every element in this matrix to zero
METHOD PUBLIC Clear
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FillTrapezoidal(0,0,0);]]></ST>
      </Implementation>
    </Method>
    <Property Name="Cols" Id="{d523fd23-40b0-0c12-048f-35d989fa4f45}" FolderPath="Properties\">
      <Declaration><![CDATA[//Total number of columns in this matrix
PROPERTY PUBLIC ABSTRACT Cols : UINT]]></Declaration>
      <Get Name="Get" Id="{a7a6e0d6-1627-0349-3c56-d4f322f68321}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CopyFrom" Id="{dae02926-a792-0e0c-1dd5-5763605fc7fb}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*Copy the value from each element in the source matrix to each corresponding element in this matrix

:Prerequisites:
 - This matrix is the same size as the source matrix
 - Neither matrix is empty
 
 *)
METHOD PUBLIC CopyFrom : BOOL//Returns true if the prerequisites were met and the data was copied, false otherwise
VAR_IN_OUT CONSTANT
	M : Matrix;//Source of the copy operation
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CopyFrom := Matrix_Copy(M_From := M, M_To := THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyTo" Id="{8ef25dfb-afc0-053f-1591-86389e6847af}" FolderPath="Helpers\">
      <Declaration><![CDATA[(*Copy the value from each element in this matrix to each corresponding element in the destination matrix

:Prerequisites:
 - This matrix is the same size as the destination matrix
 - Neither matrix is empty
 
 *)
METHOD PUBLIC CopyTo : BOOL//Returns true if the prerequisites were met and the data was copied, false otherwise
VAR_IN_OUT
	M : Matrix;//Destination for the copy operation
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CopyTo := Matrix_Copy(THIS^,M);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ElementDifference" Id="{e1125626-a54e-0cea-3fa3-0f21fba9398c}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*
For each element in this matrix, calculate a new value by Subtracting the value of the corresponding element of the supplied matrix from the value in this matrix

THIS := THIS - M

:Prerequisites:
 - This matrix is the same size as the supplied matrix
 - Neither matrix is empty
 
 *)
METHOD PUBLIC ElementDifference : BOOL//TRUE if the operation completes successfully, false if the prerequisites are not met
VAR_IN_OUT CONSTANT
	M : Matrix;//the subtrahend in the subtraction
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ElementDifference := Matrix_ElementDifference(THIS^,M,THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ElementProduct" Id="{0f328a92-3951-078e-3107-736a766f63a8}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*
For each element in this matrix, calculate a new value by Multiplying the value of the corresponding element of the supplied matrix with the value in this matrix

THIS := THIS .* M

:Prerequisites:
 - This matrix is the same size as the supplied matrix
 - Neither matrix is empty
 
 *)
METHOD PUBLIC ElementProduct : BOOL//TRUE if the operation completes successfully, false if the prerequisites are not met
VAR_IN_OUT CONSTANT
	M : Matrix;//the supplied matrix to be multiplied element-by-element to this matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ElementProduct := Matrix_ElementProduct(THIS^,M,THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ElementSum" Id="{009657bb-27d7-0cc7-0f12-e292b249bb77}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*
For each element in this matrix, calculate a new value by Adding the value of the corresponding element of the supplied matrix with the value in this matrix

THIS := THIS + M

:Prerequisites:
 - This matrix is the same size as the supplied matrix
 - Neither matrix is empty
 
 *)
METHOD PUBLIC ElementSum : BOOL//TRUE if the operation completes successfully, false if the prerequisites are not met
VAR_IN_OUT CONSTANT
	M : Matrix;//the supplied matrix to be added to this matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ElementSum := Matrix_ElementSum(THIS^,M,THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="FillFrom" Id="{022b237b-0584-4ce7-a547-77e65ab3d048}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*
For every element that exist in both this matrix and the source matrix, copy the value from the source matrix into this matrix
*)
METHOD PUBLIC FillFrom
VAR_IN_OUT CONSTANT
	M : Matrix;//source matrix for element copy operation
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF M.IsEmpty OR IsEmpty THEN
	RETURN;//no need to fill to/from empty matricies, and it
END_IF

FOR Ri := 0 TO MIN(Rows,M.Rows)-1 DO
	FOR Ci := 0 TO MIN(Cols,M.Cols)-1 DO
		SetRC(Ri,Ci,M.GetRC(Ri,Ci));
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FillFromArray2D" Id="{2cb8ce14-15ec-0e5f-0bdb-629074473dbd}" FolderPath="Modifiers\">
      <Declaration><![CDATA[(*
For every element that exist in both this matrix and the source array, copy the value from the source array into this matrix
*)
METHOD PUBLIC FillFromArray2D
VAR_IN_OUT CONSTANT
	A : ARRAY[*,*] OF LREAL;//source matrix for element copy operation
END_VAR
VAR
	inRows : UINT;
	inCols : UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF LOWER_BOUND(A,1) < UPPER_BOUND(A,1) OR LOWER_BOUND(A,2) < UPPER_BOUND(A,2)  OR IsEmpty THEN
	RETURN;//no need to fill to/from empty matricies
END_IF

inRows := DINT_TO_UINT(UPPER_BOUND(A,1) - LOWER_BOUND(A,1) + 1);
inCols := DINT_TO_UINT(UPPER_BOUND(A,2) - LOWER_BOUND(A,2) + 1);

FOR Ri := 0 TO MIN(Rows,inRows)-1 DO
	FOR Ci := 0 TO MIN(Cols,inCols)-1 DO
		SetRC(Ri,Ci,A[LOWER_BOUND(A,1)+Ri,LOWER_BOUND(A,2)+Ci]);
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FillFromAt" Id="{57397ef9-06ec-050d-1f21-ec905dd7b0ad}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Consider the subset of elements in this matrix starting and the supplied initial row and column as a submatrix. 
//For every element that exists in both the submatrix and the supplies source matrix, copy the value from the source matrix into the corresponding element of the submatrix.
METHOD PUBLIC FillFromAt
VAR_IN_OUT CONSTANT
	M : Matrix;//Source matrix for the copy operation
END_VAR
VAR_INPUT
	RStart : UINT;//Row within this matrix to start the fill operation
	CStart : UINT;//Column within this matrix to start the fill operation
END_VAR

VAR
	SubMatrix : SubMatrixAccessor;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF M.IsEmpty THEN
	LogWarning('%s: Attempt to fill from an empty matrix');
	RETURN;
END_IF

IF IsEmpty THEN
	LogWarning('%s: Attempt to fill into an empty matrix');
	RETURN;
END_IF

IF RStart >= Rows THEN
	LogWarning('%s: Attempt to fill out of bounds row of matrix');
	RETURN;
END_IF

IF CStart >= Cols THEN
	LogWarning('%s: Attempt to fill out of bounds col of matrix');
	RETURN;
END_IF

SubMatrix := GetSubMatrixAccessor(RStart,Rows-Rstart,CStart,Cols-CStart);
SubMatrix.FillFrom(M);]]></ST>
      </Implementation>
    </Method>
    <Method Name="FillTrapezoidal" Id="{f5fa3a45-37d2-08ef-0015-41ed1be8ef4b}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Fills all elements of this matrix based on which of three zones it is located into when considered as a trapezoidal matrix
METHOD PUBLIC FillTrapezoidal
VAR_INPUT
	Diagonal : LREAL;//Every element on the main diagonal of the matrix is set to this value.
	UpperRight : LREAL;//Every element above or to the right of the main diagonal is set to this value;
	LowerLeft : LREAL;//Every element below or to the left of the main diagonal is set to this value;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	LogWarning('%s: Attempt to trapezoid fill an empty matrix');
	RETURN;
END_IF


FOR Ri := 0 TO Rows-1 DO
	FOR Ci := 0 TO Cols-1 DO
		IF Ri = Ci THEN
			SetRC(Ri,Ci,Diagonal);
		ELSIF Ri < Ci THEN
			SetRC(Ri,Ci,UpperRight);
		ELSE
			SetRC(Ri,Ci,LowerLeft);
		END_IF
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetDeterminant" Id="{4690878e-585c-49dd-a170-b0f3c7ff17f5}" FolderPath="Getters\">
      <Declaration><![CDATA[//Gets the determinant of this matrix
//
//:Prerequisites:
// - Matrix is not empty
// - Matrix is square
//
//.. note:: If this matrix does not meet the requirements 0 is returned
METHOD PUBLIC GetDeterminant : LREAL//The determinant of this matrix, if the prerequisites are met. Otherwise, returns 0.
VAR_INPUT
END_VAR
VAR
	Res : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT(Matrix_DeterminateSquare(M := THIS^,Res => Res)) THEN
	LogWarning('%s: Unable to calculate determinate');
	GetDeterminant := 0;
ELSE
	GetDeterminant := Res;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetI" Id="{15777527-77a2-42cc-8d9c-f624271cdfcd}" FolderPath="Getters\">
      <Declaration><![CDATA[//Gets the value of the element in this matrix at the supplied location as if the elements were stored in a 1D row-major array
//
//:Prerequisites:
// - I < Rows*Cols
// - Matrix is not empty
//
//.. note:: If the supplied index is out of bounds the value 0 is returned and a warning is generated in the Error List
METHOD PUBLIC ABSTRACT GetI : LREAL//The value of the element at the specified index, or 0 if an invalid index is supplied
VAR_INPUT
	I : UINT;//The index of the element which should have its value returned
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetRC" Id="{fa44f9d9-95b5-4fc6-badf-738b5a3911f1}" FolderPath="Getters\">
      <Declaration><![CDATA[//returns the value of the element of this matrix at the specified row and column.
//
//:Prerequisites:
// - Row < Rows
// - Col < Cols
// - Matrix is not empty
//
//.. note:: If the supplied or or column is out of bounds then a warning message is generated in the Error List and the value 0 is returned
METHOD PUBLIC GetRC : LREAL//The value of the element at the specified row and column, or 0 if an invalid index is supplied
VAR_INPUT
	Row : UINT;//The row of the element to fetch
	Col : UINT;//The column of the element to fetch
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	GetRC := 0;
	LogWarning('%s: Attempted RC access of empty Matrix');
ELSIF
	Row >= Rows THEN
	GetRC := 0;
	LogWarning('%s: Attempted RC access of out-of-bound matrix row');
ELSIF
	Col >= Cols THEN
	GetRC := 0;
	LogWarning('%s: Attempted RC access of out-of-bounds Matrix column');
ELSE
	GetRC := GetI(RC2I(Row,Col));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetShrunkMatrixAccessor" Id="{a17e9bb7-2275-05d1-18ac-48a4fa653049}" FolderPath="Accessors\">
      <Declaration><![CDATA[METHOD PUBLIC GetShrunkMatrixAccessor : ShrunkMatrixAccessor
VAR_INPUT
	Row : UINT;
	Col : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetShrunkMatrixAccessor.Init(THIS^,Row,Col);]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetSize" Id="{61a33f57-364a-4e27-9ba3-9caf9ad98b8f}" FolderPath="Getters\">
      <Declaration><![CDATA[//Returns the length of the matrix in the specified dimension
//
// - GetSize(0) is equivalent to Rows
// - GetSize(1) is equivalent to Cols
//
//.. note:: If an invalid dimension is supplied then a warning is generated in the Error List and the value 0 is returned
METHOD PUBLIC GetSize : UINT//The length of the matrix in the specified dimension, or 0 if the dimension specified is invalid
VAR_INPUT
	Dim : UINT;//The dimension of the matrix for which the size should be returned. 0=Rows, 1=Cols
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Dim = 0 THEN
	GetSize := Rows;
ELSIF Dim = 1 THEN
	GetSize := Cols;
ELSE
	LogWarning('%s: Attempted to GetSize for a dimension other than 0 or 1');
	GetSize := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStringLengthEstimate" Id="{105d6985-ce7b-0363-01e4-eb441c24368f}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Calulates how long of a string (in Bytes) is required in order to print the entire contents of the matrix using the WriteDataToString function
METHOD PUBLIC GetStringLengthEstimate : UDINT;
VAR_INPUT
END_VAR
VAR
	CharsPerElement : UDINT := 20;//15 point precision, decimal, sign, leading zero, comma, space
	CharsPerRow : UDINT := 6;//space, semicolon, carriage return, line return, space, space
	CharsPerMatrix : UDINT := 4;//open bracket, space ; space, closing bracket
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetStringLengthEstimate := 1+CharsPerMatrix + CharsPerRow * Rows + CharsPerElement * Length;//extra one for null character]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetSubMatrixAccessor" Id="{a144ad62-4358-0927-0b6b-026cfc4aa1d5}" FolderPath="Accessors\">
      <Declaration><![CDATA[METHOD PUBLIC GetSubMatrixAccessor : SubMatrixAccessor
VAR_INPUT
	RowStart : UINT;
	RowCount : UINT;
	ColStart : UINT;
	ColCount : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetSubMatrixAccessor.Init(THIS^,RowStart,RowCount,ColStart,ColCount);]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetTransposeMatrixAccessor" Id="{5dc6f40a-ecba-0ce5-0744-b541aad5ef72}" FolderPath="Accessors\">
      <Declaration><![CDATA[METHOD PUBLIC GetTransposeMatrixAccessor : TransposeMatrixAccessor
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetTransposeMatrixAccessor.Init(THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetVectorDotProduct" Id="{1658fad0-9792-0d13-3da1-4022c6478285}" FolderPath="Getters\">
      <Declaration><![CDATA[//Returns the vector dot product of this matrix and the supplied other matrix (ignoring the orientation of both matricies).
//:Prerequisites:
// - This matrix is a vector and is not empty
// - The supplied other matrix is a vector and is not empty
// - This vector has the same length (but not necessarily orientation) as the supplied vector
METHOD PUBLIC GetVectorDotProduct : LREAL//The dot product (element-wise product) of this vector and the supplied vector, or 0 if the inputs are invalid
VAR_IN_OUT CONSTANT
	V : Matrix;//The vector which which the dot product of this vector should be taken.
END_VAR
VAR
	Res : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT(Vector_DotProduct(V,THIS^,Res => Res)) THEN
	LogWarning('%s: Unable to calculate vector dot product');
	GetVectorDotProduct := 0;
ELSE
	GetVectorDotProduct := Res;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetVectorMagnitude" Id="{2cda7f0d-36ea-0716-0a39-1b669b254390}" FolderPath="Getters\">
      <Declaration><![CDATA[//Calcualtes the vector magnitude of this matrix (square root of the sum of the squares), assuming it is a vector.
//
//:Prerequisites:
// - This matrix is not empty and is a vector
//
//.. note:: If this matrix is empty or is not a vector, 0 is returned
METHOD PUBLIC GetVectorMagnitude : LREAL//The vector magnitude of this matrix if it is a vector, otherwise 0
VAR_INPUT
END_VAR
VAR
	Res : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT(Vector_Magnitude(THIS^,Res => Res)) THEN
	LogWarning('%s: Unable to calculate vector magnitude');
	GetVectorMagnitude := 0;
ELSE
	GetVectorMagnitude := Res;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IC2RC" Id="{7255f7df-750d-0f66-22e3-0b875b59a237}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED IC2RC
VAR_INPUT
	Index : UINT;
	ColCount : UINT;
END_VAR
VAR_OUTPUT
	Row : UINT;
	Col : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Col := Index MOD ColCount;
Row := (Index - Col) / ColCount;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IntPower" Id="{6bdcc943-6222-00fa-3a06-a537022f40c0}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Raises every element of the matrix to the supplied power
METHOD PUBLIC IntPower
VAR_INPUT
	Exponent : INT;//Power with which to raise every element of the matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	RETURN;
END_IF
FOR I := 0 TO Length-1 DO
	SetI(I,EXPT(GetI(I),Exponent));
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="InvertSquare" Id="{a64d1a3c-dedb-0302-0073-1fce8da4a4ec}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Inverts the matrix. May fail if the matrix is too close to being singular. Use the tolerance input to specify how close to go (1E-6 to 1E-9 is porbably good).
//
//:Prerequisites:
//- This matrix is square
//- This matrix is not empty
METHOD PUBLIC InvertSquare : BOOL//True if the inverse has been calculated. False if a precondition was not met, or a near-singularity was detected (data may be malformed).
VAR_INPUT
	Tolerance : LREAL;//The smallest magnitude of number that is allowed to be used as a denominator in the calculation of the inverse
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[InvertSquare := Matrix_InvertSquare(THIS^,Tolerance);]]></ST>
      </Implementation>
    </Method>
    <Property Name="IsEmpty" Id="{c235a1c3-19da-47f7-9309-34932eb65324}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Returns true if the matrix does not have any addresible elements
PROPERTY PUBLIC IsEmpty : Bool]]></Declaration>
      <Get Name="Get" Id="{ae4f7dd7-6afa-42b8-914f-506a87feabaa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsEmpty := Length = 0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="IsEqual" Id="{864b7d2e-c191-4c91-985a-939f8832c318}" FolderPath="Comparators\">
      <Declaration><![CDATA[//Determines if this matrix is equal to a supplied matrix.
//
//Two matricies are considered equal if they are the same size and every set of corresponding elements are equal.
//
//.. note:: Two empty matricies are considered equal.
METHOD PUBLIC IsEqual : BOOL//TRUE if the two matricies are equal, FALSE if they are not
VAR_IN_OUT CONSTANT
	M : Matrix;//The other matrix to compare to this one
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT( IsEqualSize(M)) THEN
	IsEqual := FALSE;
	RETURN;
END_IF

//If either matrix is empty don't bother comparing elements
IF IsEmpty OR M.IsEmpty THEN
	//If both are empty then they are equal
	IsEqual := IsEmpty AND M.IsEmpty;
	RETURN;
END_IF

//Both Rows and Cols must be non zero for this loop to not go bonkers
FOR Ri := 0 TO Rows-1 DO
	FOR Ci := 0 TO Cols-1 DO
		IF NOT(GetRC(Ri,Ci) = M.GetRC(Ri,Ci)) THEN
			IsEqual := FALSE;
			RETURN;
		END_IF
	END_FOR
END_FOR

IsEqual := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsEqualSize" Id="{27be0354-ccaa-4d4d-aa11-92c8ff0d05d2}" FolderPath="Comparators\">
      <Declaration><![CDATA[//Checks if this matrix is the same size (number of rows and number of columns match) as the supplied matrix.
//
//.. note:: two empty matricies are considered the same size.
METHOD PUBLIC IsEqualSize : BOOL//True if this matrix is the same size as the supplied matrix
VAR_IN_OUT CONSTANT
	M : Matrix;//The matrix which should have its size compared to the size of this matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsEqualSize := M.Rows = Rows AND M.Cols = Cols;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsNearlyEqual" Id="{5d748479-c05b-0288-3d27-e100bad6055b}" FolderPath="Comparators\">
      <Declaration><![CDATA[//Determines if this matrix is *nearly* equal to a supplied matrix, based on a supplied precision.
//
//Two matricies are considered nearly equal if they are the same size and every set of corresponding elements are equal to within the supplied precision.
//.. note:: Note that two empty matricies are considered equal
METHOD PUBLIC IsNearlyEqual : BOOL//TRUE if the two matricies are nearly equal, FALSE if they are not
VAR_IN_OUT CONSTANT
	M : Matrix;//The other matrix to compare to this one
END_VAR
VAR_INPUT
	Precision : LREAL;//Deviation between two elements larger than this value makes them unequal
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT( IsEqualSize(M)) THEN
	IsNearlyEqual := FALSE;
	RETURN;
END_IF

//If either matrix is empty don't bother comparing elements
IF IsEmpty OR M.IsEmpty THEN
	//If both are empty then they are equal
	IsNearlyEqual := IsEmpty AND M.IsEmpty;
	RETURN;
END_IF

//Both Rows and Cols must be non zero for this loop to not go bonkers
FOR Ri := 0 TO Rows-1 DO
	FOR Ci := 0 TO Cols-1 DO
		IF NOT( ABS(GetRC(Ri,Ci) - M.GetRC(Ri,Ci)) < Precision) THEN
			IsNearlyEqual := FALSE;
			RETURN;
		END_IF
	END_FOR
END_FOR

IsNearlyEqual := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsNearZero" Id="{14d96c82-fff9-0250-2cd6-b017194a9777}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Returns true if the supplied value is near enough to zero that it should not be used as a divisor. See the property ZeroReference
METHOD PROTECTED IsNearZero : BOOL
VAR_INPUT
	IN : LREAL;//The value which should have its magnitude evaluated
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsNearZero := ABS(IN) < ZeroReference;]]></ST>
      </Implementation>
    </Method>
    <Property Name="IsSquare" Id="{e672b3bd-9ada-4884-9298-de073113df9b}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Returns true if this matrix is not empty, and the number of columns is equal to the number of rows
PROPERTY PUBLIC IsSquare : BOOL]]></Declaration>
      <Get Name="Get" Id="{4255b8b2-db7d-4f6c-90fc-32930d8d75f2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsSquare := NOT(IsEmpty) AND Rows = Cols;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsVector" Id="{fa53e68e-f9cd-4264-b4bc-c5aa3563b636}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Returns true if this matrix is not empty, and at least one dimension has a size of 1 (row vector or column vector).
PROPERTY PUBLIC IsVector : BOOL]]></Declaration>
      <Get Name="Get" Id="{37d299d5-2a39-4c73-888a-5f06acc43d3e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsVector := NOT(IsEmpty) AND (Rows = 1) OR (Cols = 1);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Length" Id="{2c497c08-f008-0342-1d0c-6819a4969e69}" FolderPath="Properties\">
      <Declaration><![CDATA[//Total number of elements in this matrix
PROPERTY PUBLIC Length : UINT]]></Declaration>
      <Get Name="Get" Id="{fc001511-17d0-03a1-3ade-ffcc96d39c1c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Length := Rows * Cols;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="LogError" Id="{0d93f53f-aa75-038c-24c9-4008df3d6da2}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Logs the supplied message to the error output as an 'Error'
METHOD PROTECTED LogError
VAR_INPUT
	Message : T_MaxString;//The message to log. %s is substituted with the symbolic address of this matrix.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ADSLOGSTR(ADSLOG_MSGTYPE_WARN,Message,sPath);]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogEvent" Id="{8171c1d6-5906-0bfd-0ba5-b722be9c1e72}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Logs the supplied message to the windoes event log
METHOD PROTECTED LogEvent
VAR_INPUT
	Message : T_MaxString;//The message to log. %s is substituted with the symbolic address of this matrix.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ADSLOGSTR(ADSLOG_MSGTYPE_LOG,Message,sPath);]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogMessage" Id="{97d8748b-f9e0-0605-025f-e9b0af536375}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Logs the supplied message to the error output as a 'Message'
METHOD PROTECTED LogMessage
VAR_INPUT
	Message : T_MaxString;//The message to log. %s is substituted with the symbolic address of this matrix.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ADSLOGSTR(ADSLOG_MSGTYPE_STRING,Message,sPath);]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogWarning" Id="{9209617a-719a-05c3-2a97-800df97be0bd}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Logs the supplied message to the error output as a 'Warning'
METHOD PROTECTED LogWarning
VAR_INPUT
	Message : T_MaxString;//The message to log. %s is substituted with the symbolic address of this matrix.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ADSLOGSTR(ADSLOG_MSGTYPE_WARN,Message,sPath);]]></ST>
      </Implementation>
    </Method>
    <Property Name="MaxVal" Id="{2e28b031-b417-0f4a-0152-01ef3cd1db57}" FolderPath="Aggregators\">
      <Declaration><![CDATA[//Returns the maximum value from all elements
PROPERTY PUBLIC MaxVal : LREAL]]></Declaration>
      <Get Name="Get" Id="{f7bebe36-e3d7-072e-0310-06c7d57e73dc}">
        <Declaration><![CDATA[VAR
	MaxVal_ : LREAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF IsEmpty THEN
	MaxVal := 0;
ELSE
	MaxVal_ := GetI(0);
	FOR I := 1 TO Length-1 DO
		IF getI(I) < MaxVal_ THEN
			MaxVal_ := GetI(I);
		END_IF
	END_FOR
	MaxVal := MaxVal_;
END_IF
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MinVal" Id="{02b2c522-52fd-07a2-0002-77487d44cc65}" FolderPath="Aggregators\">
      <Declaration><![CDATA[//Returns the minimum value from all elements
PROPERTY PUBLIC MinVal : LREAL]]></Declaration>
      <Get Name="Get" Id="{cbaba9d2-d69b-0140-2c06-09a756014561}">
        <Declaration><![CDATA[VAR
	MinVal_ : LREAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF IsEmpty THEN
	MinVal := 0;
ELSE
	MinVal_ := GetI(0);
	FOR I := 1 TO Length-1 DO
		IF getI(I) < MinVal_ THEN
			MinVal_ := GetI(I);
		END_IF
	END_FOR
	MinVal := MinVal_;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Normalize" Id="{404b4c10-5aeb-0370-10b6-f0f7c656ed69}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Scales every element of the matrix by the inverse of the magnitude.
//
// - Vector magnitude is determined by GetVectorMagnitude
// - Square Matrix magnitude is determined by GetDeterminate
// - Rectangular matricies produce an error
//
//:Prerequisites: 
// - matrix is not empty
// - matrix is not rectangular
METHOD PUBLIC Normalize : BOOL//TRUE if the matrix was normalized. FALSE if not.
VAR_INPUT
END_VAR
VAR
	Mag : LREAL;
END_VAR
VAR CONSTANT
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	Normalize := FALSE;
	LogWarning('%s: Unable to normalize matrix because it is empty');
	RETURN;
ELSIF IsVector THEN
	Mag := GetVectorMagnitude();
ELSIF IsSquare THEN
	Mag := GetDeterminant();
ELSE
	Normalize := FALSE;
	LogWarning('%s: Unable to normalize matrix because it is not square or a vector');
	RETURN;
END_IF

IF IsNearZero(Mag) THEN
	Normalize := FALSE;
	LogWarning('%s: Unable to normalize matrix because the magnitude was too close to zero');
	RETURN;
END_IF

Normalize := TRUE;

Scale(1/Mag);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Power" Id="{554d7c44-e24f-0d64-3e72-fbca02a11c79}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Raises every element of the matrix to the supplied power
//
//.. caution:: Many values of exponent could easily cause all of the elements to turn into NaN!
METHOD PUBLIC Power
VAR_INPUT
	Exponent : LREAL;//Power with which to raise every element of the matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	RETURN;
END_IF
FOR I := 0 TO Length-1 DO
	SetI(I,EXPT(GetI(I),Exponent));
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="RC2I" Id="{3fa58cb3-47e4-0750-1d7e-28cc355ab4a5}" FolderPath="Protected\">
      <Declaration><![CDATA[//Computes the index in a row-major 1D array representing this Matrix given a supplied Row and Column index
METHOD PROTECTED RC2I : UINT//The 0-based index of the element in the 1D array
VAR_INPUT
	Row : UINT;//The target row of the element
	Col : UINT;//The target column of the element
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RC2I := RCC2I(Row,Col,Cols);]]></ST>
      </Implementation>
    </Method>
    <Method Name="RCC2I" Id="{a76e2565-d4ef-4b3c-baf9-76f94e292fe8}" FolderPath="Protected\">
      <Declaration><![CDATA[//Computes the index in a row-major 1D array representing a Matrix with the supplied number of columns (*NOT this matrix*) given a supplied Row and Column index
METHOD PROTECTED RCC2I : UINT//Index of the element in a 1D array
VAR_INPUT
	Row : UINT;//Row of the target element
	Col : UINT;//Column fo the target element
	ColCount : UINT;//The number of columns in the 1D array (not necessarilly the number of columns in this Matrix!)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RCC2I := Row*ColCount + Col;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Rows" Id="{d28429c0-8643-0547-1543-63793204cffa}" FolderPath="Properties\">
      <Declaration><![CDATA[//Total number of rows in this matrix
PROPERTY PUBLIC ABSTRACT Rows : UINT]]></Declaration>
      <Get Name="Get" Id="{38f7288d-05a9-0a44-1ad7-57f45d3df90f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Scale" Id="{b7f3a516-3a74-41d5-8946-fd12d55e7c87}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Scales every element of this matrix by the supplied value.
METHOD PUBLIC Scale
VAR_INPUT
	Scalar : LREAL;//Value with which to scale every element of this matrix
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Matrix_Scale(THIS^,Scalar);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetI" Id="{1887d363-8acf-46d8-a10f-82241082042b}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Sets the element specified by the supplied index to the suppleid value, assuming the data of the matrix is stored in a 1D row-major array
//
//:Prerequisites: - I < Rows*Cols
METHOD PUBLIC ABSTRACT SetI : BOOL//TRUE if the specified index is valid and the data is copied. FLASE otherwise
VAR_INPUT
	I : UINT;//The index specifying which element should be modified
	Val : LREAL;//The value copied to the corresponding element
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetRC" Id="{95b644b0-5978-469a-8c47-6f924bbad114}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Sets the element specified by the supplied row and column to the suppleid value
//
//:Prerequisites:
// - Row < Rows
// - Col < Cols
METHOD PUBLIC SetRC : BOOL;//TRUE if the specified row and column are valid and the data is copied. FALSE otherwise
VAR_INPUT
	Row : UINT;//The row of the element to set
	Col : UINT;//The column of the element to set
	Val : LREAL;//The value to copy into the specified element
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty THEN
	SetRC := FALSE;
	LogWarning('%s: Attempt to set data using RC access when data is not initialized');
ELSIF Row >= Rows THEN
	SetRC := FALSE;
	LogWarning('%s: Attempt to set data using RC access when Row is out of bounds');
ELSIF Col >= Cols THEN
	SetRC := FALSE;
	LogWarning('%s: Attempt to set data using RC access when Col is out of bounds');
ELSE
	SetRC := SetI(RC2I(Row,Col),Val);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SortByColAsc" Id="{ea20e01d-e4b6-07c7-3aa6-8ff1eae01e44}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//In-place bubble sort of rows by the specified col, into ascending order
//
//algorithm is 'stable', meaning that two equivalent rows will maintain their relative position after sorting.
//This is nice because it lets you sort by secondary/tertiary/etc columns (if you do them in reverse)
METHOD PUBLIC SortByColAsc : BOOL
VAR_INPUT
	SortCol : UINT;
END_VAR
VAR
	lastUnsortedRow : UINT;
	lastSwappedRow : UINT;
	Result : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ISEmpty OR Rows <= 1 THEN
	SortByColAsc := FALSE;
	RETURN;
END_IF

lastUnsortedRow := Rows-1;
Result := TRUE;
REPEAT
	lastSwappedRow := 0;
	FOR Ri := 1 TO lastUnsortedRow DO
		IF GetRC(Ri-1,SortCol) >GetRC(Ri,SortCol) THEN
			Result := Result AND SwapRow(Ri-1,Ri);
			lastSwappedRow := Ri;
		END_IF
	END_FOR
	lastUnsortedRow := lastSwappedRow-1;
UNTIL
	lastSwappedRow = 0
END_REPEAT]]></ST>
      </Implementation>
    </Method>
    <Property Name="sPath" Id="{71b212c0-e2af-08e9-0666-16cfb7faa00b}" FolderPath="Properties\">
      <Declaration><![CDATA[//The symbolic path to this matrix in memory
PROPERTY PUBLIC sPath : T_MaxString]]></Declaration>
      <Get Name="Get" Id="{5efaf036-abb9-0591-2a9d-5c04faea0e41}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sPath := sPath_;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Sum" Id="{26264213-af04-0fe3-15b5-fce4debe5ded}" FolderPath="Aggregators\">
      <Declaration><![CDATA[//Returns the sum of all elements
PROPERTY PUBLIC Sum : LREAL]]></Declaration>
      <Get Name="Get" Id="{98d20894-bd36-02b2-129d-e600f0a5d072}">
        <Declaration><![CDATA[VAR
	Sum_ : LREAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Sum_ := 0;
IF NOT(IsEmpty) THEN
	FOR I := 0 TO Length-1 DO
		Sum_ := Sum_ + GetI(I);
	END_FOR
END_IF
Sum := Sum_;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="SwapI" Id="{9903fd37-3838-001f-0889-4b12e9ed20cb}" FolderPath="Modifiers\">
      <Declaration><![CDATA[METHOD PUBLIC SwapI : BOOL
VAR_INPUT
	I1 : UINT;
	I2 : UINT;
END_VAR
VAR
	Temp : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty OR I1 >= Length OR I2 >= Length THEN
	SwapI := FALSE;
	RETURN;
END_IF
Temp := GetI(I1);
SwapI := SetI(I1,GetI(I2));
SwapI := SwapI AND SetI(I2,Temp);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SwapRC" Id="{2c8eb746-15d7-0307-168a-2971c506e35a}" FolderPath="Modifiers\">
      <Declaration><![CDATA[METHOD PUBLIC SwapRC : BOOL
VAR_INPUT
	R1 : UINT;
	C1 : UINT;
	R2 : UINT;
	C2 : UINT;
END_VAR
VAR
	Temp : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty OR R1 >= Rows OR R2 >= Rows OR C1 >= Cols OR C2 >= Cols THEN
	SwapRC := FALSE;
	RETURN;
END_IF
Temp := GetRC(R1,C1);
SwapRC := SetRC(R1,C1,GetRC(R2,C2));
SwapRC := SwapRC AND SetRC(R2,C2,Temp);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SwapRow" Id="{4b7c7a69-fd7e-02b2-3da1-2a7e363dfa18}" FolderPath="Modifiers\">
      <Declaration><![CDATA[METHOD PUBLIC SwapRow : BOOL
VAR_INPUT
	R1 : UINT;
	R2 : UINT;
END_VAR
VAR
	Result : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty OR R1 >= Rows OR R2 >= Rows THEN
	SwapRow := FALSE;
	RETURN;
END_IF


FOR Ci := 0 TO Cols-1 DO
	IF NOT(SwapRC(R1,Ci,R2,Ci)) THEN
		SwapRow := FALSE;
		RETURN;
	END_IF
END_FOR

SwapRow := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TransposeSquare" Id="{e53a992d-b14e-03c8-244a-30c9a5ab7640}" FolderPath="Modifiers\">
      <Declaration><![CDATA[//Transposes the matrix.
//
//:Prerequisites:
//- This matrix is square
//- This matrix is not empty
METHOD PUBLIC TransposeSquare : BOOL//TRUE if the operation completes successfully, false if the prerequisites are not met
VAR_INPUT
END_VAR
VAR
	Temp : DynamicMatrix;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TransposeSquare := Matrix_TransposeSquare(THIS^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteDataToString" Id="{7c9446a3-69a9-08e8-3b1c-3852339b4db4}" FolderPath="Helpers\">
      <Declaration><![CDATA[//Writes the elements of this matrix to a string in a human-readable way, up to the specified length.
//
//Use the GetStringLengthEstimate function to calculate how much memory is necessary to output the entire matrix to one string
METHOD PUBLIC WriteDataToString : BOOL//Returns true if the entire matrix was written to the string, false otherwise
VAR_INPUT
	Buffer : POINTER TO STRING;//The output buffer that should be overwritten with the contents of the matrix
	BufferLen : UDINT;//The length, in bytes, of the output buffer available fo writing
END_VAR
VAR
	Temp : STRING(32);
	Pos : UDINT;
END_VAR
VAR CONSTANT
	ColSep : STRING(2) := ', ';
	RowSep : STRING(6) := ' ;$R$L  ';
	MatStart : STRING(2) := '[ ';
	MatEnd : STRING(2) := ' ]';
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Pos := 0;
IF NOT(STRNCPY(Buffer+Pos,ADR(MatStart),BufferLen-Pos)) THEN
	WriteDataToString := FALSE;
	RETURN;
END_IF;
Pos := Pos + LEN2(ADR(MatStart));

FOR Ri := 0 TO Rows-1 DO
	IF Ri <> 0 THEN
		IF NOT(STRNCPY(Buffer+Pos,ADR(RowSep),BufferLen-Pos)) THEN
			WriteDataToString := FALSE;
			RETURN;
		END_IF;
		Pos := Pos + LEN2(ADR(RowSep));
	END_IF;

	FOR Ci := 0 TO Cols-1 DO
		IF Ci <> 0 THEN
			IF NOT(STRNCPY(Buffer+Pos,ADR(ColSep),BufferLen-Pos)) THEN
				WriteDataToString := FALSE;
				RETURN;
			END_IF;
			Pos := Pos + LEN2(ADR(ColSep));
		END_IF;
		
		Temp := LREAL_TO_STRING(GetRC(Ri,Ci));
		IF NOT(STRNCPY(Buffer+Pos,ADR(Temp),BufferLen-Pos)) THEN
			WriteDataToString := FALSE;
			RETURN;
		END_IF;
		Pos := Pos + LEN2(ADR(Temp));
	END_FOR
END_FOR

IF NOT(STRNCPY(Buffer+Pos,ADR(MatEnd),BufferLen-Pos)) THEN
	WriteDataToString := FALSE;
	RETURN;
END_IF;
Pos := Pos + LEN2(ADR(MatEnd));
WriteDataToString := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Property Name="ZeroReference" Id="{c759c62c-8641-003b-19d2-c7e06780aedd}" FolderPath="Properties\">
      <Declaration><![CDATA[//Values with a magnitude lower than this value will be considered as zero for purposes of avoiding divide by zero errors
PROPERTY PUBLIC ZeroReference : LREAL]]></Declaration>
      <Get Name="Get" Id="{72e7fd1c-4821-0afe-1307-1af2cfef9288}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ZeroReference := ZeroReference_;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b7e81f92-1be0-0ef9-012d-c2c5baa8b706}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ZeroReference_ := ZeroReference;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <LineIds Name="Matrix">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Average.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.BufferSize.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Clear">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Cols.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.CopyFrom">
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.CopyTo">
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.ElementDifference">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.ElementProduct">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.ElementSum">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.FillFrom">
      <LineId Id="40" Count="7" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.FillFromArray2D">
      <LineId Id="29" Count="10" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.FillFromAt">
      <LineId Id="89" Count="19" />
      <LineId Id="7" Count="0" />
      <LineId Id="109" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.FillTrapezoidal">
      <LineId Id="5" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="20" Count="3" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetDeterminant">
      <LineId Id="39" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="53" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetI">
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetRC">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetShrunkMatrixAccessor">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetSize">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="9" Count="2" />
      <LineId Id="17" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetStringLengthEstimate">
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetSubMatrixAccessor">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetTransposeMatrixAccessor">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetVectorDotProduct">
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.GetVectorMagnitude">
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IC2RC">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IntPower">
      <LineId Id="15" Count="2" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.InvertSquare">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsEmpty.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsEqual">
      <LineId Id="5" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="34" Count="2" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="48" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsEqualSize">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsNearlyEqual">
      <LineId Id="5" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="34" Count="2" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="53" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsNearZero">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsSquare.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.IsVector.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Length.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.LogError">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.LogEvent">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.LogMessage">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.LogWarning">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.MaxVal.Get">
      <LineId Id="5" Count="8" />
      <LineId Id="16" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.MinVal.Get">
      <LineId Id="5" Count="8" />
      <LineId Id="15" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Normalize">
      <LineId Id="5" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="3" />
      <LineId Id="31" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="25" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Power">
      <LineId Id="15" Count="2" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.RC2I">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.RCC2I">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Rows.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Scale">
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.SetI">
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.SetRC">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.SortByColAsc">
      <LineId Id="12" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.sPath.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.Sum.Get">
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="2" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.SwapI">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="2" />
    </LineIds>
    <LineIds Name="Matrix.SwapRC">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="2" />
    </LineIds>
    <LineIds Name="Matrix.SwapRow">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.TransposeSquare">
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.WriteDataToString">
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="36" Count="2" />
      <LineId Id="34" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="42" Count="5" />
      <LineId Id="25" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="51" Count="3" />
      <LineId Id="50" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="28" Count="3" />
      <LineId Id="27" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="55" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.ZeroReference.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Matrix.ZeroReference.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>